
# Wishlist

We explain here which are the functionnalities we plan to implement in near future.


## Implement search engine :

We planned from the get go to implement this feature allowing users to search specific algorithms from the catalog. Here are the fields that can be used to filter the results : 

* Author's username
* Name of Algorithm
* Date (Min and Max): of the creation on the platform
* Price (Min and Max) : allows you to see only algorithms where at least on version satisfies these conditions.

We imagine some the fields can allow for regular expressions. We also imagine that the condition can be combined together (using logical AND or OR). 

## Decide a billing system :

We studied the billing possibilities and the one that stood out - thefore we favor - is taxing the contributors for the cost of running the algorithm and repay him hopefully with part of the cost of processing. 

The cost of running refers to the cost in infrastructure level when the algorithm consumes resources on AlgoFab. The cost of processing on the other hand is value generated by the algorithm througout it's utilization.

This is how this billing system works : 

* Users buy credits on the Portal.
* They use the credits to make API calls to an algorithm.
* Credits are deduced based on the version of algorithm (amount determined by the author to value his algorithm) and the elapsed time till the response is retrieved. This is the processing cost.
* We convert the processing cost in a monetary currency (Euros) that will be shared between Algofab and the author of the algorithm (we are currently thinking of 10% vs 90% ratio, 90% for the contributor).  
* The processing will trigger higher consumption of resources. At the end of the month, the author will be asked to pay the cost related to that utilization. This is the running cost.

<aside class="notice">
	This biiling system is not decided on yet and is likely to change and defnitely need more refining. Anyhow this is the current orientation though not decided yet.
</aside>

## Response Retrieve Method (RRM) in API mode:

According to the kind of processing of one algorithm and also the request, the time to wait for the response can be pretty long. Ideally we would proxy the request sent by the client to the API server, the server replies immediatly and to client. However if the processing takes too much time, we need to think of ways to get the response through other means to response, because HTTP is not suitable for long-lived requests. Hence the RRMs we are going to describe.

We plan to add an optional field to the manifest to express the RRM. The key will be **RRM** and the value will be amongst : **synchronous**, **pooling**, **partial response** or **websocket**. The default value will be synchronous. 

Let's see the diferences between these methods.

### Synchronous RRM :

The Synchronous RRM is the default and the most simple and straight-forward one when we respond to a request with the output of the algorithm. Like mentionned above, this works if the response is almost instantaneous. You can of course increase the timeout of your API server, nevertheless the infrastructure of some clients will likely be configured to not let pass too long-lived requests. Therefore even if you increase the timeout, there might be a problem for the client to get back it's response. This is the case for example for clients behind a proxy trying to access your algorithm. Since the proxy has its own timeout, then the request is more likely to fail (with an Error 504 : Gateway timeout).

### Pooling RRM :

The pooling RRM consists of the server - upon receiving a request - to send an ID as a response to the client in order to avoid a long lived HTTP request. The user can use the said id to ask periodically for the actual response to the server. When the algorithm is done processing, the server includes the response of the algorithm in an object and replies the next request of the client by that abject. 


### Partial Response RRM :

This method goes against the very idea of keeping the HTTP requests short (therefore we discourage using it) but has the advantage of sending the response as soon as it is available.

The idea is that - upon receiving a request - the server keeps sending partial responses (HTTP 206) to the client until the response is available, then sends it. 

### Websocket RRM :

This method consists of creating a websocket between the client and the API server. It is very straight forward and seems to be the best compromise.
 
